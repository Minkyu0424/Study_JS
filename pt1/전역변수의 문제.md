### 14.1 변수의 생명주기

- 선언에 의한 생성, 할당, 소멸되는 생명주기를 가짐.
- 지역변수의 경우, 자신이 선언된 위치에서 함수 호출시 생성, 함수 종료 시 소멸함
    - 지역변수의 경우 함수 호출 직후, 함수 코드 실행 전에 선언됨
    - 지역변수의 생명주기는 함수의 생명주기와 일치함.
- 지역변수는 함수가 생성한 스코프에 등록되고, 누군가 스코프를 참조 시, 소멸하지 않고 생존함.
    - 이 경우엔 함수 종료시에도 스코프는 존재
- 호이스팅은 스코프 단위로 동작함.
    - 변수 선언의 경우 전역변수는 전역 스코프, 지역변수는 지역 스코프의 선두로 올려진 것처럼 동작
- 전역코드는 명시적인 호출 없이 실행 됨. var로 선언한 전역변수는 전역 객체의 프로퍼티가 됨
    - 전역객체: 코드 실행 이전 JS엔진에 의해 생성되는 특수객체(window, gloal)
    

### 14.2 전역변수의 문제점

1. 암묵적 결합(모든 코드가 참조, 변경이 가능)
2. 긴 생명주기(메모리 리소스 오래 소비)
    1. 변수 이름의 중복 가능성(의도치 않은 재할당 가능성)
3. 스코프 체인 상 종점에 존재
    1. 변수의 검색 속도가 느림
4. 네임 스페이스 오염
    1. 다른 파일내 동일한 이름의 전역변수, 전역함수가 같은 스코프에 존재 시 문제발생

### 14.3 전역변수 사용 억제 방법

1. 즉시 실행함수(정의와 동시에 호출)
    1. 모든 변수는 즉시 실행함수의 지역변수가 됨(전역변수 생성 x)
2. 네임스페이스 역할 담당 객체 생성
    1. 전역변수로 사용하고픈 변수를 프로퍼티로 추가(식별자충돌방지)
3. 모듈 패턴(클래스 모방해 관련있는 변수 함수를 모아 즉시실행함수로 감쌈)
    1. 전역변수 억제 + 캡슐화 구현가능
        1. `캡슐화` : 객체의 프로퍼티와 메서드를 하나로 묶는 것
            1. 프로퍼티, 메서드를 감추는데 사용(정보 은닉)
    
    ```jsx
    var Counter=(function(){
    	var num = 0;
    	return{
    		increase() {
    			return ++num;
    			},
    			decrease(){
    				return--num;
    			};
    		}
    }());
    //즉시 실행함수는 객체를 반환함. 
    // 이 객체엔 외부 공개할 변수, 함수를 담아서 반환한다.
    ```
    
4. ES6 모듈
    1. 파일 자체의 독자적 모듈 스코프를 제공
        1. 모듈 내에서 var 키워드로 선언한 변수는 전역변수, window 객체 프로퍼티가 아님