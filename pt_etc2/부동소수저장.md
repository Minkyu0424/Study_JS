부동소수점 연산의 오차 때문입니다.

1. 부동소수점 숫자 표현 (IEEE 754)

JavaScript의 숫자는 IEEE 754 표준의 64비트 부동소수점 숫자(배정밀도, double-precision floating-point)로 표현됩니다.
이 표준에서는 실수를 **이진수(2진법)**로 변환하여 저장하는데, 일부 십진수(10진법) 숫자는 이진수로 정확하게 표현할 수 없습니다.

예를 들어:
	•	0.1 → 0.0001100110011001100110011001100110011001100110011... (무한 반복)
	•	1.1 → 1.0001100110011001100110011001100110011001100110011... (무한 반복)

이처럼 0.1과 1.1은 이진수로 완벽하게 표현되지 못하고 근사값으로 저장됩니다.
따라서 덧셈 연산(0.1 + 1.1)을 하면 미세한 오차가 발생할 수 있습니다.

⸻

2. 실제 계산 과정

JavaScript에서 0.1 + 1.1을 실행하면 내부적으로 다음과 같은 연산이 진행됩니다.

console.log(0.1 + 1.1);  // 1.2000000000000002

이것은 부동소수점 오차 때문에 발생하는 현상이며, 1.2가 아닌 1.2000000000000002라는 값이 출력됩니다.

⸻

3. 해결 방법

이 문제를 해결하려면 소수점 자리수를 제한하거나 정수 연산으로 변환하는 방법을 사용할 수 있습니다.

(1) toFixed() 사용

console.log((0.1 + 1.1).toFixed(2));  // "1.20"

주의: toFixed()는 문자열을 반환하므로, 숫자로 변환하려면 parseFloat()을 사용하세요.

console.log(parseFloat((0.1 + 1.1).toFixed(2)));  // 1.2

(2) Math.round() 사용

10배, 100배 등 정수로 변환 후 다시 나누기 하면 오차를 줄일 수 있습니다.

console.log(Math.round((0.1 + 1.1) * 100) / 100);  // 1.2

(3) 외부 라이브러리 사용 (Big.js, Decimal.js)

정확한 부동소수점 연산이 필요하다면 big.js 또는 decimal.js 같은 라이브러리를 사용할 수도 있습니다.

const Big = require('big.js');
console.log(new Big(0.1).plus(1.1).toString());  // "1.2"



⸻

4. 결론
JavaScript에서 0.1 + 1.1이 정확히 1.2가 아닌 이유는:
	1.	IEEE 754 부동소수점 표기 방식을 사용하기 때문
	2.	0.1과 1.1을 이진수로 정확히 표현할 수 없어서 작은 오차가 발생하기 때문

이 문제는 모든 부동소수점 연산에서 발생할 수 있는 공통적인 문제이며, 해결하려면 toFixed(), Math.round(), 또는 외부 라이브러리를 활용하면 됩니다. 🚀